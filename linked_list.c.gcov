        -:    0:Source:linked_list.c
        -:    0:Graph:./linked_list.gcno
        -:    0:Data:./linked_list.gcda
        -:    0:Runs:1
        -:    1:#include "linked_list.h"
        -:    2:#include "iterator.h"
        -:    3:#include <assert.h>
        -:    4:#include <stdbool.h>
        -:    5:#include "string.h"
        -:    6:
        -:    7:
        -:    8:struct link
        -:    9:{
        -:   10:    elem_t element;
        -:   11:    ioopm_link_t *next;
        -:   12:};
        -:   13:
        -:   14:struct list
        -:   15:{
        -:   16:    ioopm_link_t *first;
        -:   17:    ioopm_link_t *last;
        -:   18:    size_t size; // Added field to store the number of elements in the linked list.
        -:   19:    ioopm_eq_function equal_fun;
        -:   20:};
        -:   21:
       17:   22:ioopm_list_t *ioopm_linked_list_create(ioopm_eq_function equal_fun)
        -:   23:{
       17:   24:    ioopm_list_t *new_list = calloc(1, sizeof(ioopm_list_t));
       17:   25:    new_list->first = NULL;
       17:   26:    new_list->last = NULL;
       17:   27:    new_list->size = 0;
       17:   28:    new_list->equal_fun = equal_fun;
       17:   29:    return new_list;
        -:   30:}
        -:   31:
       77:   32:void links_destroy(ioopm_link_t *link) {
        -:   33:  // Cache the next pointer
       77:   34:  ioopm_link_t *next = link->next;
       77:   35:  free(link);
       77:   36:  if (next != NULL) {
       62:   37:    links_destroy(next);
        -:   38:  }
       77:   39:}
        -:   40:
       17:   41:void ioopm_linked_list_destroy(ioopm_list_t *list) {
       17:   42:    if (list->first == NULL && list->last == NULL) {
        2:   43:        free(list);
        -:   44:    } else {
       15:   45:        links_destroy(list->first);
       15:   46:        free(list);
        -:   47:    }
       17:   48:}
        -:   49:
       13:   50:void ioopm_linked_list_append(ioopm_list_t *list, elem_t value)
        -:   51:{
       13:   52:    ioopm_link_t *new_link = calloc(1, sizeof(ioopm_link_t));
        -:   53:    
       13:   54:    new_link->element = value;
       13:   55:    new_link->next = NULL;
        -:   56:    // Increment size by one
       13:   57:    list->size = list->size + 1;
       13:   58:    if (list->last == NULL && list->first == NULL) {
        -:   59:        // TODO: ska man uppdatera first också till new_link? Svar: Det hjälper att göra så när man använder list_destroy.
        4:   60:        list->first = new_link;
        4:   61:        list->last = new_link;
        -:   62:    } else {
        9:   63:        list->last->next = new_link;
        9:   64:        list->last = new_link;
        -:   65:    }
       13:   66:}
        -:   67:
       70:   68:void ioopm_linked_list_prepend(ioopm_list_t *list, elem_t value)
        -:   69:{
       70:   70:    ioopm_link_t *new_link = calloc(1, sizeof(ioopm_link_t));
       70:   71:    new_link->element = value;
       70:   72:    new_link->next = list->first;
       70:   73:    if (list->last == NULL && list->first == NULL) {
       12:   74:        list->first = new_link;
       12:   75:        list->last = new_link;
        -:   76:    }
       70:   77:    list->first = new_link;
        -:   78:    // Increment size by one
       70:   79:    list->size = list->size + 1;
       70:   80:}
        -:   81:
       23:   82:size_t ioopm_linked_list_size(ioopm_list_t *list) {
       23:   83:    return list->size;
        -:   84:}
        -:   85:
        9:   86:void ioopm_linked_list_insert(ioopm_list_t *list, int index, elem_t value) {
        9:   87:    size_t length = ioopm_linked_list_size(list);
        9:   88:    int counter = 1;
        -:   89:    // If we insert at the head of the list
        9:   90:    if (index == 0) {
        2:   91:        ioopm_linked_list_prepend(list, value);
        -:   92:    // If we insert at the last element
        7:   93:    } else if (length == index) {
        1:   94:        ioopm_linked_list_append(list, value);
        -:   95:    } else {
        6:   96:        ioopm_link_t *linked_link = list->first;
       12:   97:        while (counter != index - 1 && index != 1) {
        6:   98:            linked_link = linked_link->next;
        6:   99:            counter = counter + 1;
        -:  100:        }
        6:  101:        ioopm_link_t *new_link = calloc(1, sizeof(ioopm_link_t));
        6:  102:        new_link->element = value;
        6:  103:        new_link->next = linked_link->next;
        6:  104:        linked_link->next = new_link;
        -:  105:       // Increment size by one
        6:  106:       list->size = list->size + 1;
        -:  107:    }
        9:  108:}
        -:  109:
        1:  110:elem_t ioopm_linked_list_get(ioopm_list_t *list, int index)
        -:  111:{
        1:  112:    int counter = index;
        1:  113:    ioopm_link_t *list_itr = list->first;
        3:  114:    while (counter != 0) {
        2:  115:        list_itr = list_itr->next;
        2:  116:        counter--;
        -:  117:    }
        1:  118:    return list_itr->element;
        -:  119:} 
        1:  120:bool ioopm_linked_list_is_empty(ioopm_list_t *list) {
        1:  121:    return list->size == 0;
        -:  122:}
        -:  123:
        2:  124:bool ioopm_linked_list_contains(ioopm_list_t *list, elem_t element) {
        2:  125:    ioopm_link_t *linked_list = list->first;
        5:  126:    for (int i = 0; i < list->size; i++) {
        4:  127:        if (list->equal_fun(linked_list->element, element)) {
        1:  128:            return true;
        -:  129:        } else {
        3:  130:            linked_list = linked_list->next;
        -:  131:        }
        -:  132:    }
        1:  133:    return false;
        -:  134:}
        -:  135:
       12:  136:elem_t ioopm_linked_list_remove(ioopm_list_t *list, int index) {
       12:  137:    int counter = 1;
       12:  138:    if (index == 0 && list->first->next != NULL) { // (When we want to remove the first element in the list)
        -:  139:        // We move the pointer of the first element to the next element in the list 
        -:  140:        // And free the removed elements memory and return it's value
        8:  141:        ioopm_link_t *free_the_struct1 = list->first;
        8:  142:        list->first = list->first->next;
        8:  143:        elem_t removed_first_element = free_the_struct1->element;
        8:  144:        free(free_the_struct1);
        8:  145:        list->size = list->size - 1;
        8:  146:        return removed_first_element;
        -:  147:
        4:  148:    } else if (list->size - 1 == index) { // (When we want to remove the last element in the list)
        -:  149:        // We move the pointer of the last element to the previous element in the list by iterating to the penultimate element
        -:  150:        // And free the removed elements memory and return it's value
        2:  151:       if (list->first->next == NULL) {
        1:  152:        elem_t removed_final_element = list->first->element;
        1:  153:        ioopm_link_t *free_the_struct1 = list->first;
        1:  154:        list->first = NULL;
        1:  155:        list->last = NULL;
        1:  156:        free(free_the_struct1);
        -:  157:        
        1:  158:        return removed_final_element;    
        -:  159:       }
        -:  160:
        1:  161:        ioopm_link_t *free_the_struct = list->last;
        1:  162:        ioopm_link_t *next_link = list->first;
        1:  163:        list->size = list->size - 1;
        -:  164:
        4:  165:        while (counter != list->size) {
        3:  166:            next_link = next_link->next;
        3:  167:            counter = counter + 1;
        -:  168:        }
        1:  169:        list->last = next_link;
        1:  170:        next_link->next = NULL;
        1:  171:        elem_t removed_last_element = free_the_struct->element;
        1:  172:        free(free_the_struct);
        1:  173:        return removed_last_element;
        -:  174:
        -:  175:    } else { 
        -:  176:        // We find the previous element and point it's next pointer to the element after the intented removed element
        -:  177:        // And free the removed elements memory and return it's value
        2:  178:        ioopm_link_t *linked_list = list->first;
        2:  179:        counter = counter - 1;
        3:  180:        while (counter != index - 1) {
        1:  181:            linked_list = linked_list->next;
        1:  182:            counter = counter + 1;
        -:  183:        }
        2:  184:        ioopm_link_t *free_the_struct2 = linked_list->next;
        2:  185:        linked_list->next = linked_list->next->next;
        -:  186:        
        2:  187:        list->size = list->size - 1;
        2:  188:        elem_t removed_element = free_the_struct2->element;
        2:  189:        free(free_the_struct2);
        2:  190:        return removed_element;
        -:  191:    }
        -:  192:}
        -:  193:
        1:  194:void ioopm_linked_list_clear(ioopm_list_t *list) {
        1:  195:    size_t size = list->size;
        8:  196:    for (int i = 0; i < size; i++) {
        7:  197:        ioopm_linked_list_remove(list, 0);
        -:  198:    }
        1:  199:}
        -:  200:
        -:  201:
        6:  202:bool ioopm_linked_list_all(ioopm_list_t *list, ioopm_int_predicate prop, void *extra)
        -:  203:{
        6:  204:    size_t size = ioopm_linked_list_size(list);
        6:  205:    ioopm_link_t *list_itr = list->first;
        -:  206:
       17:  207:    for (int i = 0; i < size; i++) {
       12:  208:        if (!prop(list_itr->element, extra)) {
        1:  209:            return false;   
        -:  210:        } else {
       11:  211:            list_itr = list_itr->next;
        -:  212:        }
        -:  213:    } 
        5:  214:    return true;
        -:  215:}
        -:  216:
        3:  217:bool ioopm_linked_list_any(ioopm_list_t *list, ioopm_int_predicate prop, void *extra)
        -:  218:{
        3:  219:    size_t size = ioopm_linked_list_size(list);
        3:  220:    ioopm_link_t *list_itr = list->first;
        -:  221:
        6:  222:    for (int i = 0; i < size; i++) {
        4:  223:        if (prop(list_itr->element, extra)) {
        1:  224:            return true;   
        -:  225:        } else {
        3:  226:            list_itr = list_itr->next;
        -:  227:        }
        -:  228:    } 
        2:  229:    return false;
        -:  230:}
        -:  231:
        3:  232:void ioopm_linked_list_apply_to_all(ioopm_list_t *list, ioopm_apply_int_function fun, void *extra) 
        -:  233:{
        3:  234:    size_t size = ioopm_linked_list_size(list); 
        3:  235:    ioopm_link_t *list_itr = list->first;
        3:  236:    int counter = 0;
        -:  237:
        -:  238:    
       11:  239:    while (counter != size) {
        8:  240:        elem_t *a = &(list_itr->element);
        8:  241:        fun(a, extra);
        8:  242:        counter++;
        8:  243:        list_itr = list_itr->next;
        -:  244:    }
        3:  245:}
        -:  246:
        -:  247:
        -:  248:
        -:  249:struct iter 
        -:  250:{
        -:  251:  ioopm_link_t *current;
        -:  252:  ioopm_list_t *list; /// New field
        -:  253:};
        -:  254:
        4:  255:ioopm_list_iterator_t *ioopm_list_iterator(ioopm_list_t *list)
        -:  256:{
        4:  257:  ioopm_list_iterator_t *result = calloc(1, sizeof(struct iter));
        -:  258:
        4:  259:  result->current = list->first;
        4:  260:  result->list = list; /// Iterator remembers where it came from
        -:  261:
        4:  262:  return result; 
        -:  263:}
        -:  264:
        6:  265:void ioopm_iterator_next(ioopm_list_iterator_t *iter)
        -:  266:{
        6:  267:  iter->current = iter->current->next;
        6:  268:}
        -:  269:
        1:  270:elem_t ioopm_iterator_current(ioopm_list_iterator_t *iter)
        -:  271:{
        1:  272:  return iter->current->element; 
        -:  273:}
        -:  274:
        4:  275:void ioopm_iterator_destroy(ioopm_list_iterator_t *iter)
        -:  276:{
        4:  277:  free(iter);
        4:  278:}
        -:  279:
        1:  280:void ioopm_iterator_reset(ioopm_list_iterator_t *iter)
        -:  281:{
        1:  282:  iter->current = iter->list->first;
        1:  283:}
        -:  284:
        -:  285:// int ioopm_iterator_remove(ioopm_list_iterator_t *iter)
        -:  286:// {
        -:  287://   ioopm_list_iterator_t *to_remove = iter->current; 
        -:  288://   int result = to_remove->current->element;
        -:  289:
        -:  290://   iter->current->next = to_remove->current->next; 
        -:  291:
        -:  292://   free(to_remove); 
        -:  293:
        -:  294://   return result;
        -:  295:// }
